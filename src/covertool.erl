-module(covertool).

%% command line entry point for escriptize
-export([main/1]).

%% application entry point
-export([generate_report/2]).

-include("covertool.hrl").
-include_lib("xmerl/include/xmerl.hrl").

-define(EUNIT_DIR, ".eunit").

-record(result, {line = {0, 0},
                 branches = {0, 0},
                 data = []}).

main([]) ->
    usage();
main(Args) ->
    Config = process_args(Args, #config{}),
    CoverData = Config#config.cover_data,
    io:format("Importing '~s' data file...~n", [CoverData]),
    cover:import(CoverData),
    io:format("Found ~w modules.~n", [length(cover:imported_modules())]),

    generate_report(Config, cover:imported_modules()),
    io:format("Done.~n"),
    ok.

usage() ->
    ScriptName = escript:script_name(),
    io:format("Usage: ~s [Options]~n", [ScriptName]),
    io:format("Options:~n"),
    io:format("    -apps    AppsDir        Path to a root directory where app dirs reside (default: \"./\")~n"),
    io:format("    -cover   CoverDataFile  Path to the cover exported data set (default: \"all.coverdata\")~n"),
    io:format("    -output  OutputFile     File to put generated report to (default: \"coverage.xml\")~n"),
    ok.

% Parse arguments into record
process_args([], Config) -> Config;
process_args([[$- | Name] , Value | Args], Config) ->
    NameAtom = list_to_atom(Name),
    process_args(Args, update_config(NameAtom, Value, Config));
process_args(_Args, _Config) ->
    usage(),
    halt(1).

update_config(cover, Value, Config) ->
    Config#config{cover_data = Value};
update_config(output, Value, Config) ->
    Config#config{output = Value};
update_config(apps, Value, Config) ->
    Config#config{apps = Value};
update_config(_Other, _Value, _Config) ->
    usage(),
    halt(1).

generate_report(Config, Modules) ->
    Output = Config#config.output,
    case Config#config.cover_data of
        no_import ->
            ok;
        CoverData ->
            cover:import(CoverData)
    end,
    put(apps, Config#config.apps),
    put(sources, sources()),
    io:format("Generating report '~s'...~n", [Output]),
    Prolog = ["<?xml version=\"1.0\" encoding=\"utf-8\"?>\n",
              "<!DOCTYPE coverage SYSTEM \"http://cobertura.sourceforge.net/xml/coverage-04.dtd\">\n"],

    {MegaSecs, Secs, MicroSecs} = now(),
    Timestamp = MegaSecs * 1000000000 + Secs * 1000 + (MicroSecs div 1000), % in milliseconds

    Version = "1.9.4.1", % emulate Cobertura 1.9.4.1
    Complexity = 0, % not supported at the moment

    Result = generate_packages(Modules),
    {LinesCovered, LinesValid} = Result#result.line,
    LineRate = rate(Result#result.line),

    {BranchesCovered, BranchesValid} = Result#result.branches,
    BranchRate = rate(Result#result.branches),

    Apps = filename:absname(get(apps)),
    Root = {coverage, [{timestamp, Timestamp},
                       {'line-rate', LineRate},
                       {'lines-covered', LinesCovered},
                       {'lines-valid', LinesValid},
                       {'branch-rate', BranchRate},
                       {'branches-covered', BranchesCovered},
                       {'branches-valid', BranchesValid},
                       {complexity, Complexity},
                       {version, Version}],
            [{sources, [{source, [Apps]}]},
             {packages, Result#result.data}]},
    Report = xmerl:export_simple([Root], xmerl_xml, [{prolog, Prolog}]),
    write_output(Report, Output),
    ok.

generate_packages(Modules) ->
    PackageAndModules =
        lists:foldl(fun(Module, Acc) ->
                        PackageName = package_name(Module),
                        case lists:keyfind(PackageName, 1, Acc) of
                            false ->
                                [{PackageName, [Module]} | Acc];
                            {_Key, ModulesInPackage} ->
                                lists:keyreplace(
                                  PackageName, 1, Acc,
                                  {PackageName, [Module|ModulesInPackage]})
                        end
                    end, [], Modules),
    Fun = fun({PackageName, ModulesInPackage}, Result) ->
                  Package = generate_package(PackageName, ModulesInPackage),
                  {Package#result.data, sum(Result, Package)}
          end,
    {Packages, Result} = lists:mapfoldl(Fun, #result{}, PackageAndModules),
    Result#result{data = Packages}.

%% Package name is generated by
%% - source directory
package_name(Module) when is_atom(Module) ->
    case lookup_source(Module) of
        false -> "NoPackage";
        {AppName, _, _} -> AppName
    end.

generate_package(PackageName, Modules) ->
    Classes = generate_classes(Modules),
    Data = {package, [{name, PackageName},
                      {'line-rate', rate(Classes#result.line)},
                      {'branch-rate', rate(Classes#result.branches)},
                      {complexity, 0}],
            [{classes, Classes#result.data}]},
    #result{data = Data}.

% generate <classes> element, each Erlang module is "class"
generate_classes(Modules) ->
    % generate XML for every class, collect summary metric
    Fun = fun(Module, Result) ->
                  Class = generate_class(Module),
                  {Class#result.data, sum(Result, Class)}
          end,
    
    % Skip modules without sources
    Filter = fun(Module) ->
        case lookup_source(Module) of
         false -> false;
         _Other -> true
        end
    end,
    Modules2 = lists:filter(Filter, Modules),
    {Classes, Result} = lists:mapfoldl(Fun, #result{}, Modules2),
    Result#result{data = Classes}.

generate_class(Module) ->
    Fun = fun({{_Module, Line}, Value}, Result) ->
                  Covered = case Value of 0 -> 0; _Other -> 1 end,
                  LineCoverage = sum(Result#result.line, {Covered, 1}), % add one line to the summary
                  Data = {line, [{number, Line},
                                 {hits, Value}],
                          []},
                  {Data, Result#result{line = LineCoverage}}
          end,
    {ok, Lines} = cover:analyse(Module, calls, line),

    % XXX: ignore zero-indexed line, for some reason it is always present and always not hit
    Filter = fun({{_Module, 0}, 0}) -> false;
                (_Other) -> true
             end,
    Lines2 = lists:filter(Filter, Lines),
    {LinesData, Result} = lists:mapfoldl(Fun, #result{}, Lines2),

    {_, Filename, _} = lookup_source(Module),

    Data = {class, [{name, Module},
                    {filename, Filename},
                    {'line-rate', rate(Result#result.line)},
                    {'branch-rate', rate(Result#result.branches)},
                    {complexity, 0}],
            [{methods, generate_methods(Module, LinesData)},
             {lines, LinesData}]},
    Result#result{data = Data}.

generate_methods(Module, LinesData) ->
    ResultFun = fun ({line, LineData, _}, Result) ->
                    Hits = proplists:get_value(hits, LineData, 0),
                    Covered = case Hits of 0 -> 0; _Other -> 1 end,
                    LineCoverage = sum(Result#result.line, {Covered, 1}),
                    Result#result{line = LineCoverage}
                end,

    {ok, Functions} = cover:analyse(Module, calls, function),
    MFAs = lists:map(fun (F) -> element(1, F) end, Functions),
    lists:flatten(lists:map(
        fun ({_M, F, A} = MFA) ->
                case function_lines(MFA, LinesData) of
                    [] -> [];
                    FunLinesData ->
                        Result = lists:foldl(ResultFun, #result{}, FunLinesData),
                        {method, [{name, F},
                                  {signature, io_lib:format("~s/~B", [F, A])},
                                  {'line-rate', rate(Result#result.line)},
                                  {'branch-rate', rate(Result#result.branches)}],
                                 [{lines, FunLinesData}]}
                end
        end, MFAs)).

write_output(Report, Output) ->
    io:format("Writing output report '~s'...~n", [Output]),
    case file:open(Output, [write, {encoding, utf8}]) of
        {ok, Fd} ->
            ok = file:write(Fd, [Report, "\n"]),
            file:close(Fd);
        {error, Reason} ->
            io:format("Could not open '~s' due to ~p.~n", [Output, Reason]),
            halt(1)
    end,
    ok.

% sum metrics
sum(#result{line = {LineCovered1, LineValid1}, branches = {BranchesCovered1, BranchesValid1}},
    #result{line = {LineCovered2, LineValid2}, branches = {BranchesCovered2, BranchesValid2}}) ->
    #result{line = {LineCovered1 + LineCovered2, LineValid1 + LineValid2},
            branches = {BranchesCovered1 + BranchesCovered2, BranchesValid1 + BranchesValid2}};
sum({Covered1, Valid1}, {Covered2, Valid2}) ->
    {Covered1 + Covered2, Valid1 + Valid2}.

rate({_Covered, 0}) -> "0.0";
rate({Covered, Valid}) -> [Res] = io_lib:format("~f", [Covered / Valid]), Res.

% lookup source in source directory
lookup_source(Module) ->
    Sources = get(sources),
    case dict:find(Module, Sources) of
        {ok, Value} -> Value;
        _ -> false
    end.

sources() ->
    Apps = get(apps),
    Files = filelib:wildcard("*/src/*.erl", Apps),
    lists:foldl(fun accum_source/2, dict:new(), Files).

accum_source(Filename, DictIn) ->
    Apps = get(apps),
    case re:run(Filename, "([^/]+)/src/([^/]+)\\.erl$", [{capture, [1,2], list}]) of
        {match, [AppName, Module]} ->
            dict:store(list_to_atom(Module), {AppName, relative_source(Apps, Filename), filename:join(Apps, AppName)}, DictIn);
        _ -> DictIn
    end.

relative_source(Apps, Filename) ->
    Name = case lists:prefix(Apps, Filename) of
        true -> lists:nthtail(length(Apps), Filename);
        false -> Filename
    end,
    case Name of
        [$/ | Relative] -> Relative;
        _Other -> Name
    end.

% lookup start and end lines for function
function_range({M, F, A}) ->
    {_, _, AppDir} = lookup_source(M),
    Beam = io_lib:format("~s/~s.beam", [filename:join(AppDir, "ebin"), M]),
    case beam_lib:chunks(Beam, [abstract_code]) of
        {error, beam_lib, _} -> {0, 0};
        {ok, {M, [{abstract_code, no_abstract_code}]}} -> {0, 0};
        {ok, {M, [{abstract_code, {_Version, AC}}]}} ->
            Filter = fun ({function, _, Fun, Ary, _}) ->
                           not (Fun =:= F andalso Ary =:= A);
                         (_) -> true
                     end,
            case lists:dropwhile(Filter, AC) of
                [] -> {0, 0}; %% Should never happen unless beam is out of sync
                [{_, Line, F, A, _}] -> {Line, Line};
                [{_, Line, F, A, _}, {eof, Next}] -> {Line, Next};
                [{_, Line, F, A, _}, Following | _] ->
                    {Line, element(2, Following) - 1}
            end
    end.

% filter lines by function
function_lines(MFA, LinesData) ->
    {Start, End} = function_range(MFA),
    lists:filter(fun (LineData) ->
                     Line = proplists:get_value(number, element(2, LineData)),
                     Line > Start andalso Line =< End
                 end, LinesData).
